.globl GetGpioAddress
GetGpioAddress:
  ldr r0,=0x3F200000 @ GPIO base address (0x20200000 on Pi < 2)
  mov pc,lr

.globl SetGpioFunction
SetGpioFunction:
  /*
  Validate arguments r0,r1
  */
  cmp r0,#53  @ GPIO has pins 0-53
  cmpls r1,#7 @ Command must be 0-7 (cmp if ls, r0 <= #53)
  movhi pc,lr @ mov if higher (mov is hi, r1 > #7, i.e. return)

  /*
  Get the GPIO base address
  After: -
   - r0 = GPIO base address
   - r1 = Pin command
   - r2 = Pin number
  */
  push {lr}
  mov r2,r0
  bl GetGpioAddress

  /*
  Keep subtracting 10 from pin number while pin number > #9 and add #4
  to GPIO base address. This calculates the correct base address for the pin
  bank (banks of 10 pins using 3 bits per pin).
  The result is equivalent to pin := pin % 10 and base := base + (4 * (pin /
  10))
  */
  functionLoop$:
    cmp r2,#9
    subhi r2,#10
    addhi r0,#4
    bhi functionLoop$

  /*
  TODO: this wipes out all other values for other pins in this bank!
  */
  add r2, r2,lsl #1 @ r2 = r2 * 3 (r2 * 2 + r2), 3 bits per pin
  lsl r1,r2         @ Shift command by pin number (e.g. 1 << (pin 7 * 3 bits) = 1 << 21)
  str r1,[r0]       @ Store command (r1) in address in r0 (GPIO base + pin offset)

  pop {pc} @ lr is on the stack from earlier, so pop its value into pc to return

.globl SetGpio
SetGpio:
  /*
  Define aliases
  */
  pinNum .req r0
  pinVal .req r1

  /*
  Validate pinNum, return if invalid
  */
  cmp pinNum,#53
  movhi pc,lr

  /*
  Redefine pinNum for r2
  */
  mov r2,pinNum
  .unreq pinNum
  pinNum .req r2

  push {lr}
  bl GetGpioAddress
  gpioAddr .req r0

  /*
  Update gpioAddr based on pin (bank)
  */
  pinBank .req r3
  lsr pinBank,pinNum,#5 @ Divide pinBank by pinNum/32
  lsl pinBank,#2        @ Multiply by 4 to get byte offset (4 bytes per pin)
  add gpioAddr,pinBank
  .unreq pinBank

  /*
  Calculate command bit for pin (pinNum % 32)
  */
  and pinNum,#31 @ Mask lower 5 bits (same as pinNum % 32)
  setBit .req r3
  mov setBit,#1
  lsl setBit,pinNum
  .unreq pinNum

  /*
  Store the value for the pin
  */
  teq pinVal,#0 @ Test pinVal equals #0
  .unreq pinVal
  streq setBit,[gpioAddr,#40] @ If pinVal == #0, store setBit in GPIO + #40 (GPCLRn)
  strne setBit,[gpioAddr,#28] @ If pinVal != #0, store setBit in GPIO + #28 (GPSETn)
  .unreq setBit
  .unreq gpioAddr

  pop {pc}
